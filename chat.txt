below is the readme and implementation
./pkg/rps/rps.go
package rps

import (
	"math/rand"
	"rps/pkg/game"
)

func GetMoveName(move game.Move) string {
	switch move {
	case Rock:
		return "rock"
	case Paper:
		return "paper"
	case Scissors:
		return "scissors"
	default:
		return "unknown"
	}
}

const (
	Rock     game.Move = 0
	Paper    game.Move = 1
	Scissors game.Move = 2
)

func Cmp(move1 game.Move, move2 game.Move) int {
	switch [2]game.Move{move1, move2} {
	case [2]game.Move{Rock, Paper}, [2]game.Move{Paper, Scissors}, [2]game.Move{Scissors, Rock}:
		return -1
	case [2]game.Move{Paper, Rock}, [2]game.Move{Scissors, Paper}, [2]game.Move{Rock, Scissors}:
		return +1
	default:
		return 0
	}
}

func randMove() game.Move {
	return game.Move(rand.Intn(3))
}

func loseTo(move game.Move) game.Move {
	switch move {
	case Rock:
		return Scissors
	case Paper:
		return Rock
	case Scissors:
		return Paper
	default:
		panic("wrong move")
	}
}

func winTo(move game.Move) game.Move {
	switch move {
	case Rock:
		return Paper
	case Paper:
		return Scissors
	case Scissors:
		return Rock
	default:
		panic("wrong move")
	}
}
./pkg/rps/player.go
package rps

import "rps/pkg/game"

func MakeConstantPlayer(move game.Move) func() game.Player {
	return func() game.Player {
		return game.MakePlayer("constant_"+GetMoveName(move), func(history [][2]game.Move) game.Move {
			return move
		})
	}
}

func MakeRandomPlayer() func() game.Player {
	return func() game.Player {
		return game.MakePlayer("random", func(history [][2]game.Move) game.Move {
			return randMove()
		})
	}
}

func MakeWinSelfPlayer() func() game.Player {
	return func() game.Player {
		return game.MakePlayer("win_self", func(history [][2]game.Move) game.Move {
			if len(history) < 1 {
				return randMove()
			}
			return winTo(history[len(history)-1][0])
		})
	}
}
func MakeLoseSelfPlayer() func() game.Player {
	return func() game.Player {
		return game.MakePlayer("lose_self", func(history [][2]game.Move) game.Move {
			if len(history) < 1 {
				return randMove()
			}
			return loseTo(history[len(history)-1][0])
		})
	}
}
func MakeWinOppoPlayer() func() game.Player {
	return func() game.Player {
		return game.MakePlayer("win_oppo", func(history [][2]game.Move) game.Move {
			if len(history) < 1 {
				return randMove()
			}
			return winTo(history[len(history)-1][1])
		})
	}
}
func MakeLoseOppoPlayer() func() game.Player {
	return func() game.Player {
		return game.MakePlayer("lose_oppo", func(history [][2]game.Move) game.Move {
			if len(history) < 1 {
				return randMove()
			}
			return loseTo(history[len(history)-1][1])
		})
	}
}
./pkg/game/simulation.go
package game

import "sync"

func Simulate(playerMakerList []func() Player, rounds int, cmp func(m1 Move, m2 Move) int, log func(p1 Player, p2 Player, m1 Move, m2 Move, ret int)) []int {
	n := len(playerMakerList)

	pointVec := make([]int, n)
	pointVecMu := sync.Mutex{}

	wg := sync.WaitGroup{}
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			wg.Add(1)
			go func(i int, j int) { // TODO at go
				defer wg.Done()
				p1, p2 := playerMakerList[i](), playerMakerList[j]()

				diff := 0
				for k := 0; k < rounds; k++ {
					m1, m2 := p1.SendMove(), p2.SendMove()
					p1.RecvMove(m2)
					p2.RecvMove(m1)

					ret := cmp(m1, m2)
					log(p1, p2, m1, m2, ret)

					switch ret {
					case +1:
						diff++
					case -1:
						diff--
					default:
					}
				}

				{
					pointVecMu.Lock()
					defer pointVecMu.Unlock()
					if diff > 0 {
						pointVec[i]++
						pointVec[j]--
					}
					if diff < 0 {
						pointVec[i]--
						pointVec[j]++
					}
				}
			}(i, j)
		}
	}
	wg.Wait()
	return pointVec
}
./pkg/game/player.go
package game

type Move int

type Player interface {
	SendMove() Move
	RecvMove(move Move)
	String() string
}

func MakePlayer(name string, sendMoveFunc func(history [][2]Move) Move) Player {
	return &playerTemplate{
		history:      nil,
		sendMoveFunc: sendMoveFunc,
		name:         name,
	}
}

type playerTemplate struct {
	history      [][2]Move
	sendMoveFunc func(history [][2]Move) Move
	name         string
}

func (p *playerTemplate) SendMove() Move {
	move := p.sendMoveFunc(p.history)
	p.history = append(p.history, [2]Move{move, -1})
	return move
}

func (p *playerTemplate) RecvMove(move Move) {
	selfLastMove := p.history[len(p.history)-1][0]
	p.history[len(p.history)-1] = [2]Move{selfLastMove, move}
}

func (p *playerTemplate) String() string {
	return p.name
}
./pkg/game/thompson.go
package game

import (
	"fmt"
	"gonum.org/v1/gonum/stat/distuv"
)

type ThompsonPlayer struct {
	armList    []Player
	winList    []int
	loseList   []int
	cmp        func(m1 Move, m2 Move) int
	lastMove   Move
	lastPlayer int
}

func (p *ThompsonPlayer) String() string {
	playerListStr := ""
	for _, player := range p.armList {
		playerListStr += player.String() + ","
	}
	return fmt.Sprintf("thompson_player_[%s]", playerListStr)
}

func NewThompsonPlayer(armMakerList []func() Player, cmp func(m1 Move, m2 Move) int) *ThompsonPlayer {
	armList := make([]Player, len(armMakerList))
	for i, playerMaker := range armMakerList {
		armList[i] = playerMaker()
	}
	return &ThompsonPlayer{
		armList:  armList,
		winList:  make([]int, len(armList)),
		loseList: make([]int, len(armList)),
		cmp:      cmp,
	}
}

func (p *ThompsonPlayer) SendMove() Move {
	// choose player
	probList := make([]float64, len(p.armList))
	for i := range probList {
		prob := randBeta(float64(p.winList[i]+1), float64(p.loseList[i]+1))
		probList[i] = prob
	}

	i := argmax(probList)
	// use player
	move := p.armList[i].SendMove()
	p.lastMove = move
	p.lastPlayer = i
	return move
}

func (p *ThompsonPlayer) RecvMove(move Move) {
	ret := p.cmp(p.lastMove, move)
	switch ret {
	case +1:
		p.winList[p.lastPlayer]++
	case -1:
		p.loseList[p.lastPlayer]++
	default:
	}
	p.armList[p.lastPlayer].RecvMove(move)
}

func randBeta(alpha float64, beta float64) float64 {
	return distuv.Beta{
		Alpha: alpha,
		Beta:  beta,
	}.Rand()
}

// argmax samples from a discrete distribution given by weights.
// It returns the selected weight.
func argmax(weights []float64) int {
	if len(weights) == 0 {
		panic("weights is empty")
	}
	i := 0
	for j := 1; j < len(weights); j++ {
		if weights[j] > weights[i] {
			i = j
		}
	}
	return i
}
do you have any comment on this?
