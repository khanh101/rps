below is the readme and implementation
./pkg/rps/rps.go
package rps

import (
	"math/rand"
	"rps/pkg/adversarial_game"
)

func MoveName(move adversarial_game.Move) string {
	switch move {
	case Rock:
		return "rock"
	case Paper:
		return "paper"
	case Scissors:
		return "scissors"
	default:
		return "unknown"
	}
}

const (
	Rock     adversarial_game.Move = 0
	Paper    adversarial_game.Move = 1
	Scissors adversarial_game.Move = 2
)

func Cmp(move1 adversarial_game.Move, move2 adversarial_game.Move) int {
	switch [2]adversarial_game.Move{move1, move2} {
	case [2]adversarial_game.Move{Rock, Paper}, [2]adversarial_game.Move{Paper, Scissors}, [2]adversarial_game.Move{Scissors, Rock}:
		return -1
	case [2]adversarial_game.Move{Paper, Rock}, [2]adversarial_game.Move{Scissors, Paper}, [2]adversarial_game.Move{Rock, Scissors}:
		return +1
	default:
		return 0
	}
}

func randMove() adversarial_game.Move {
	return adversarial_game.Move(rand.Intn(3))
}

func loseTo(move adversarial_game.Move) adversarial_game.Move {
	switch move {
	case Rock:
		return Scissors
	case Paper:
		return Rock
	case Scissors:
		return Paper
	default:
		panic("wrong Constantadversarial_game.Move")
	}
}

func winTo(move adversarial_game.Move) adversarial_game.Move {
	switch move {
	case Rock:
		return Paper
	case Paper:
		return Scissors
	case Scissors:
		return Rock
	default:
		panic("wrong Constantadversarial_game.Move")
	}
}
./pkg/rps/player.go
package rps

import (
	"math/rand"
	"rps/pkg/adversarial_game"
)

type ConstantPlayer struct {
	ConstantMove adversarial_game.Move
}

func (p *ConstantPlayer) MakeMove(history adversarial_game.History) adversarial_game.Move {
	return p.ConstantMove
}

func (p *ConstantPlayer) String() string {
	return "constant_player_" + MoveName(p.ConstantMove)
}

type WannaWinPlayer struct{}

func (p *WannaWinPlayer) MakeMove(history adversarial_game.History) adversarial_game.Move {
	if len(history) == 0 {
		return randMove()
	}
	return winTo(history[len(history)-1].OpponentMove)
}

func (p *WannaWinPlayer) String() string {
	return "wanna_win_player"
}

type WannaLosePlayer struct{}

func (p *WannaLosePlayer) MakeMove(history adversarial_game.History) adversarial_game.Move {
	if len(history) == 0 {
		return randMove()
	}
	return loseTo(history[len(history)-1].OpponentMove)
}

func (p *WannaLosePlayer) String() string {
	return "wanna_lose_player"
}

type RandomPlayer struct{}

func (p *RandomPlayer) MakeMove(history adversarial_game.History) adversarial_game.Move {
	return randMove()
}

func (p *RandomPlayer) String() string {
	return "random_player"
}

type RandomHumanPlayer struct {
	RepeatChance float64
}

func (p *RandomHumanPlayer) MakeMove(history adversarial_game.History) adversarial_game.Move {
	if len(history) == 0 {
		return randMove()
	}
	lastMove := history[len(history)-1].MyMove
	if rand.Float64() < p.RepeatChance {
		return lastMove
	}
	for {
		move := randMove()
		if move != lastMove {
			return move
		}
	}
}

func (p *RandomHumanPlayer) String() string {
	return "random_human_player"
}
./pkg/adversarial_game/simulation.go
package adversarial_game

import (
	"math/rand"
)

func Simulate(playerList []Player, rounds int, cmp func(m1 Move, m2 Move) int, log func(j int, p1 Player, m1 Move, p2 Player, m2 Move, ret int)) []int {
	pointList := make([]int, len(playerList))

	playerHistoryMat := func(n int) [][]History {
		playerHistoryMat := make([][]History, n)
		for i := 0; i < n; i++ {
			playerHistoryMat[i] = make([]History, n)
		}
		return playerHistoryMat
	}(len(playerList))

	roundList := func(n int, r int) [][2]int {
		playerPairList := [][2]int{}
		for i := 0; i < n; i++ {
			for j := i + 1; j < n; j++ {
				playerPairList = append(playerPairList, [2]int{i, j})
			}
		}

		roundList := make([][2]int, r*len(playerPairList))
		for i := 0; i < len(roundList); i++ {
			roundList[i] = playerPairList[i%len(playerPairList)]
		}

		rand.Shuffle(len(roundList), func(i int, j int) {
			roundList[i], roundList[j] = roundList[j], roundList[i]
		})
		return roundList
	}(len(playerList), rounds)

	for j, round := range roundList {
		i1, i2 := round[0], round[1]
		p1, p2 := playerList[i1], playerList[i2]
		h1, h2 := playerHistoryMat[i1][i2], playerHistoryMat[i2][i1]

		m1, m2 := p1.MakeMove(h1), p2.MakeMove(h2)
		playerHistoryMat[i1][i2] = append(playerHistoryMat[i1][i2], HistoryPoint{
			MyMove:       m1,
			OpponentMove: m2,
		})
		playerHistoryMat[i2][i1] = append(playerHistoryMat[i2][i1], HistoryPoint{
			MyMove:       m2,
			OpponentMove: m1,
		})
		ret := cmp(m1, m2)

		log(j+1, p1, m1, p2, m2, ret)
		switch ret {
		case +1:
			pointList[i1] += 1
			pointList[i2] -= 1
		case -1:
			pointList[i1] -= 1
			pointList[i2] += 1
		default:
		}
	}
	return pointList
}
./pkg/adversarial_game/player.go
package adversarial_game

type Move int

type HistoryPoint struct {
	MyMove       Move
	OpponentMove Move
}

type History = []HistoryPoint

type Player interface {
	MakeMove(history History) Move
	String() string
}
do you have any comment on this?
