below is the readme and implementation
./pkg/rps/rps.go
package rps

import (
	"math/rand"
	"rps/pkg/game"
)

func MoveName(move game.Move) string {
	switch move {
	case Rock:
		return "rock"
	case Paper:
		return "paper"
	case Scissors:
		return "scissors"
	default:
		return "unknown"
	}
}

const (
	Rock     game.Move = 0
	Paper    game.Move = 1
	Scissors game.Move = 2
)

func Cmp(move1 game.Move, move2 game.Move) int {
	switch [2]game.Move{move1, move2} {
	case [2]game.Move{Rock, Paper}, [2]game.Move{Paper, Scissors}, [2]game.Move{Scissors, Rock}:
		return -1
	case [2]game.Move{Paper, Rock}, [2]game.Move{Scissors, Paper}, [2]game.Move{Rock, Scissors}:
		return +1
	default:
		return 0
	}
}

func randMove() game.Move {
	return game.Move(rand.Intn(3))
}

func loseTo(move game.Move) game.Move {
	switch move {
	case Rock:
		return Scissors
	case Paper:
		return Rock
	case Scissors:
		return Paper
	default:
		panic("wrong move")
	}
}

func winTo(move game.Move) game.Move {
	switch move {
	case Rock:
		return Paper
	case Paper:
		return Scissors
	case Scissors:
		return Rock
	default:
		panic("wrong move")
	}
}
./pkg/rps/player.go
package rps

import (
	"rps/pkg/game"
)

type ConstantPlayer struct {
	ConstantMove game.Move
}

func (p *ConstantPlayer) SendMove() game.Move {
	return p.ConstantMove
}

func (p *ConstantPlayer) RecvMove(m game.Move) {
}

func (p *ConstantPlayer) String() string {
	return "constant_player_" + MoveName(p.ConstantMove)
}

type RandomPlayer struct{}

func (p *RandomPlayer) SendMove() game.Move {
	return randMove()
}

func (p *RandomPlayer) RecvMove(m game.Move) {
}

func (p *RandomPlayer) String() string {
	return "random_player"
}

type WannaWinOppoPlayer struct {
	game.PlayerTemplate
}

func (p *WannaWinOppoPlayer) SendMove() game.Move {
	if len(p.History) == 0 {
		return p.WrapSendMove(randMove())
	} else {
		return p.WrapSendMove(winTo(p.LastOppoMove()))
	}
}

func (p *WannaWinOppoPlayer) String() string {
	return "wanna_win_oppo_player"
}

type WannaWinSelfPlayer struct {
	game.PlayerTemplate
}

func (p *WannaWinSelfPlayer) SendMove() game.Move {
	if len(p.History) == 0 {
		return p.WrapSendMove(randMove())
	} else {
		return p.WrapSendMove(winTo(p.LastSelfMove()))
	}
}

func (p *WannaWinSelfPlayer) String() string {
	return "wanna_win_self_player"
}

type WannaLoseOppoPlayer struct {
	game.PlayerTemplate
}

func (p *WannaLoseOppoPlayer) SendMove() game.Move {
	if len(p.History) == 0 {
		return p.WrapSendMove(randMove())
	} else {
		return p.WrapSendMove(loseTo(p.LastOppoMove()))
	}
}

func (p *WannaLoseOppoPlayer) String() string {
	return "wanna_lose_oppo_player"
}

type WannaLoseSelfPlayer struct {
	game.PlayerTemplate
}

func (p *WannaLoseSelfPlayer) SendMove() game.Move {
	if len(p.History) == 0 {
		return p.WrapSendMove(randMove())
	} else {
		return p.WrapSendMove(loseTo(p.LastSelfMove()))
	}
}

func (p *WannaLoseSelfPlayer) String() string {
	return "wanna_lose_self_player"
}
./pkg/game/simulation.go
package game

import "sync"

func Simulate(playerMakerList []func() Player, rounds int, cmp func(m1 Move, m2 Move) int, log func(p1 Player, p2 Player, m1 Move, m2 Move, ret int)) []int {
	n := len(playerMakerList)

	pointVec := make([]int, n)
	pointVecMu := sync.Mutex{}

	wg := sync.WaitGroup{}
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			if i == j {
				continue
			}
			wg.Add(1)
			func(i int, j int) { // TODO at go
				defer wg.Done()
				p1, p2 := playerMakerList[i](), playerMakerList[j]()

				diff := 0
				for k := 0; k < rounds; k++ {
					m1, m2 := p1.SendMove(), p2.SendMove()
					p1.RecvMove(m2)
					p2.RecvMove(m1)

					ret := cmp(m1, m2)
					log(p1, p2, m1, m2, ret)

					switch ret {
					case +1:
						diff++
					case -1:
						diff--
					default:
					}
				}

				{
					pointVecMu.Lock()
					defer pointVecMu.Unlock()
					if diff > 0 {
						pointVec[i]++
						pointVec[j]--
					}
					if diff < 0 {
						pointVec[i]--
						pointVec[j]++
					}
				}
			}(i, j)
		}
	}
	wg.Wait()
	return pointVec
}
./pkg/game/player.go
package game

type Move int

type Player interface {
	SendMove() Move
	RecvMove(move Move)
	String() string
}
type PlayerTemplate struct {
	History [][2]Move
}

func (p *PlayerTemplate) WrapSendMove(move Move) Move {
	p.History = append(p.History, [2]Move{move, -1})
	return move
}

func (p *PlayerTemplate) LastOppoMove() Move {
	return p.History[len(p.History)-1][1]
}

func (p *PlayerTemplate) LastSelfMove() Move {
	return p.History[len(p.History)-1][0]
}

func (p *PlayerTemplate) RecvMove(move Move) {
	selfLastMove := p.History[len(p.History)-1][0]
	p.History[len(p.History)-1] = [2]Move{selfLastMove, move}
}
./pkg/game/thompson.go
package game

import (
	"fmt"
	"gonum.org/v1/gonum/stat/distuv"
)

type ThompsonPlayer struct {
	armList    []Player
	winList    []int
	loseList   []int
	cmp        func(m1 Move, m2 Move) int
	lastMove   Move
	lastPlayer int
}

func (p *ThompsonPlayer) String() string {
	playerListStr := ""
	for _, player := range p.armList {
		playerListStr += player.String() + ","
	}
	return fmt.Sprintf("thompson_player_[%s]", playerListStr)
}

func NewThompsonPlayer(armList []Player, cmp func(m1 Move, m2 Move) int) *ThompsonPlayer {
	return &ThompsonPlayer{
		armList:  armList,
		winList:  make([]int, len(armList)),
		loseList: make([]int, len(armList)),
		cmp:      cmp,
	}
}

func (p *ThompsonPlayer) SendMove() Move {
	// choose player
	probList := make([]float64, len(p.armList))
	for i := range probList {
		prob := randBeta(float64(p.winList[i]+1), float64(p.loseList[i]+1))
		probList[i] = prob
	}

	i := argmax(probList)
	// use player
	move := p.armList[i].SendMove()
	p.lastMove = move
	p.lastPlayer = i
	return move
}

func (p *ThompsonPlayer) RecvMove(move Move) {
	p.armList[p.lastPlayer].RecvMove(move)
	ret := p.cmp(p.lastMove, move)
	switch ret {
	case +1:
		p.winList[p.lastPlayer]++
	case -1:
		p.loseList[p.lastPlayer]++
	default:
	}
}

func randBeta(alpha float64, beta float64) float64 {
	return distuv.Beta{
		Alpha: alpha,
		Beta:  beta,
	}.Rand()
}

// argmax samples from a discrete distribution given by weights.
// It returns the selected weight.
func argmax(weights []float64) int {
	if len(weights) == 0 {
		panic("weights is empty")
	}
	i := 0
	for j := 1; j < len(weights); j++ {
		if weights[j] > weights[i] {
			i = j
		}
	}
	return i
}
do you have any comment on this?
